<script> // Denotes that the contents hereafter are Javascript
	// https://www.youtube.com/watch?v=PkZNo7MFNFg
	// freecodecamp.org

    // This is a line comment
    /*
    This is a block/multi-line comment
    */
    var number = 5; // This is a variable called 'number', assigned the value 5
    number = 9; // Variable reassignment
    // Data types: undefined, null, boolean, string, symbol, number, and object
    // Undefined: Variable not set yet
    // Null: Nothing is the thing it is set to
    // Boolean: True/false
    // String: Text
    // Number: A number
    // Symbol: Immutable, primitive value that is unique
    // Object: Can store key:value pairs

	console.log("Hello, World!");

    // Variable - Stores data. Can be filled with anything. Flexible typing
    // Three ways to declare
    var myName = "JaniceDoe"; // Used throughout the whole program
    let ourName = "freeCodeCamp"; // Only used in the scope declared
    const pi = 3.141569; // Variable that can never change

    // Assign vs declaration
    var a; // Declare
    a = 2; // Assign
    var b = 7; // Declare and assign

    // Console output
    console.log("The value of 'a' is: " + a);

    // Variables are case sensitive
    // JS standard is camelCasedNamingConventions, starting with lowercase

    // Arithmetic
    var c = 5 + 10; // Use the '+' operator
    var d = 15 - c; // Use the '-' operator
    console.log( c );
    console.log( d );

    var e = 10 * 10; // Use the '*' operator
    var f = 100 / 10; // Use the '/' operator
    console.log( e );
    console.log( f );

    // Increment/decrement
    c++;
    d--;
    console.log( c );
    console.log( d );

    // Decimal values (floating points/floats)
    var myDecimal = 0.0001;
    myDecimal = myDecimal * 0.0;
    console.log( myDecimal );

    // Modulo division
    var remainder = 11 % 3;
    console.log( remainder );

    // Compound assignment
    // Plus-gets, minus-gets
    remainder += 2;
    remainder -= 2;
    remainder *= 5;
    remainder /= 5;

    // String declarations
    var aString = "Alan Turing"; // String literals are things in quotes
    var bString = "This is a quotemark: \""; // Use backslash ( '\' ) to escape characters
    console.log( bString );
    var cString = 'This is also a string without escape characters: "'; // To get double quotes, use a single quote
    console.log( cString );
    var dString = `This is also a string without escape characters: "'`; // To get single quotes, use a backtick

/*  Available escape characters:
    \' - Single quote
	\" - Double quote
	\\ - Backslash
	\n - Newline
	\r - Carriage return
	\t - Tab
	\b - Backspace
	\f - Form feed
*/

	var eString = "This is string " + "concatentation.";
	console.log( eString );
	var fString = "This is also string ";
	fString += "concatenation.";
	console.log( fString );

	var quirkOne = "11" + 1; // + is string concatenation operator
	var quirkTwo = "11" - 1; // No concatenation by subtraction, arithmetic overload is the only thing left
	console.log( "QuirkOne is: " + quirkOne );
	console.log( "QuirkTwo is: " + quirkTwo );

	// 31:15
	// Length of string
	console.log( fString.length ); // Length field of String object
	// Character access by index
	console.log( fString[0] ); // 'T'

	// String immutability - Cannot be altered once created
	var gString = "Jello, World!";
	// gString[0] = "H"; // Can't do this
	// Have to overwrite the whole string
	gString = "Hello, World!";

	// To get the last letter, subtract from .length
	var lastLetter = gString[ gString.length - 1 ];
	console.log( lastLetter ); // 'T'

	// Functions	
	// 37:15
	function myFunction( arg1 ) {
        // Do things
        console.log( "Argument received: " + arg1 );
		return "something";
	}

	console.log( myFunction( 1 ) );

	// 40:48 - Arrays - Not strongly typed, can be mixed media
	var ourArray = [ "aString", 123, 2.1 ];
	// Can also be another array - Nested arrays, jagged arrays
	// Access using 0-based indexing

	var jaggedArray = [[1,2,3], [4,5,6], [7,8,9], [[10,11,12], 13, 14]];
	console.log( jaggedArray[3][0][2]); // 12 expected

	// 46:38 - Array push()
	jaggedArray.push( [97, 98, 99] );
	console.log( jaggedArray[4][2] ); // 99 expected

    // pop() - Removes the last element of an array (and returns it)
	var removed = jaggedArray.pop();
	console.log( jaggedArray ); // [97, 98, 99] removed
	console.log( removed[0] ); // 97 expected

	// 48:35 - Shift - Same as pop(), but from the front ([0])
	// 49:27 - Unshift - Same as push(), but from the front ([0])

	// 50:00 - 55:40 - Functions

	// 55:44 - Scope
	var globalVariable = 3.141569;

	function myFunction2( arg1 ) {
        // Do things
        console.log( typeof globalVariable );
        oopsThisIsGlobal = 5; // Because 'var' was not included in declaration; this is now global
		return "something";
	}

	console.log( typeof oopsThisIsGlobal ); // oopsGlobal is undefined here
	myFunction2( 1 );
	console.log( typeof oopsThisIsGlobal ); // But not undefined here

	// 1:02:00
	// If there is a naming conflict, the local variable takes precedence over the global variable

	// 1:02:41 - Function returns and assignments
	// Already demonstrated

	// 1:06:00 - Queues
	// Gotta implement it using push and shifting. No queue datatype provided
	var myQ = [1, 2, 3];

	// Adding an element to the queue at the back (right)
	function enqueue( Q, newArrival ) {
		Q.push( newArrival );
		return Q;
	}

	enqueue( myQ, 4 );

	function printArray( array ) {
		concatenator = "[ ";
		for( i = 0 ; i < array.length ; i++ ) {
			concatenator += array[i] + " ";
		}
		concatenator += "]";
		console.log( concatenator );
	}

	printArray( myQ );

	function dequeue( Q ) {
		return Q.shift( Q );
	}

	dequeue( myQ );

	printArray( myQ );

	// But why bother? Arrays have shift and push (Q and DeQ) natively; that's a queue

	// 1:09:00 - Booleans
	// 1:09:40 - If statements
	if( true ) {
		// execute this
	}
	else if( true ) {
		// then try to execute this next
	}
	else if( true ) {
		// Arbitrary number of tests
	}
	else {
		// Catchall - If nothing matches, do this
	}

	// 1:13:00 - Strict equality operator - No type coercion
	console.log( 3 === 3 );
	// 1:15:43 - Inequality operator
	console.log( 3 != "3" ); // YES to type coercion
	// 1:16:40 - Strict inequality operator
	console.log( 3 !== "3" ); // NO to type coercion
	// 1:17:00 - Greater than, lesser than comparisons
	// >=, <=
	// 1:20:00 - Logical AND, OR
	console.log( true && true )
	console.log( true || false )

	// Switch
	var caseStudy = 2;
	switch( caseStudy ) {
		case 1:
			// Do Case 1 things
		case 2:
			// Do Case 2 things
			console.log( "Hit!" );
			caseStudy = 3;
		case 3:
			console.log( "Twofer!" ); // Does not stop evaluating just because a match is found
			break; // Prevent further evaluation using a break
		case "someString":
			// Can also match to full strings, not just numbers
		default:
			// And a default behavior
	}

	// 1:42:00 - Math functions
	console.log( Math.sqrt(64) ); // 64^-2
	console.log( Math.pow( 2, 16 ) ); // 2^16
	console.log( 2^16 );
	console.log( Math.round(3.1415) ); // Coerce to the nearest int

	// 1:49:00 - Objects
	var myDog = {
		"name" : "Rover",
		"legs" : 4,
		"friends" : [ "All the things!" ]
	};

	console.log( myDog.name ); // Dot notation
	console.log( myDog["name"] ); // Bracket notation
	console.log( myDog['name'] ); // Bracket notation with single quotes
	console.log( myDog[`name`] ); // with backticks
	myDog.friends.push("JaneDoe");
	printArray( myDog.friends );

	// Adding a property
	myDog["bark"] = "Woof!";
	console.log( myDog.bark );

	// Deleting a property
	delete myDog.bark;
	console.log( myDog.bark ); // undefined expected

	// Objects are a key:value storage

	// 1:56:00 - Using objects for lookups
	var dictionary = {
		"a" : "aardvark",
		"b" : "bjork",
		"key" : "value"
	};
	var lookupResult = dictionary["key"];
	console.log( lookupResult );

	// 1:57:45 - Testing objects for properties
	console.log( myDog.hasOwnProperty( "name" ) );
	console.log( myDog.hasOwnProperty( "bark" ) );

	// 1:59:15 - Complex Objects
	// Can store objects in other objects
	var outerObject = {
		"key" : "value",
		"innerObject" : {
			"innerKey" : "innerValue"
		}
	};
	console.log( outerObject.innerObject.innerKey );

	// Backing up / deep copy of objects
	var objectOriginal = {
		"key" : "value"
	};
	var objectCopy = objectOriginal; // Sends a reference to the new object (shallow copy)
	objectCopy.key = "FooBarBaz"; // Changing this changes BOTH the original and the 'copy'

	console.log( objectOriginal.key );
	console.log( objectCopy.key );

    objectOriginal.key = "value";

	// To deep copy:
	objectCopy = JSON.parse( JSON.stringify( objectOriginal) );
	objectCopy.key = "FooBarBaz"; // Changing this changes only the 'copy'

	console.log( objectOriginal.key );
	console.log( objectCopy.key );	

	// 2:04:00 - Record collection update. Given ID#, a key, and a value, update the object appropriately
	var musicCollection = {
		"1111": {
			"album" : "Distant Worlds",
			"artist" : "Nobuo Uematsu",
			"tracks" : {
				"1" : "Opening / Bombing Mission",
				"2" : "Liberi Fatali",
				"3" : "Aerith's Theme",
				"4" : "Fisherman's Horizon",
				"5" : "Don't Be Afraid",
				"6" : "Memoro De La Stona",
				"7" : "Medley 2002",
				"8" : "Theme of Love",
				"9" : "Vamo Alla Flamenco",
				"10": "Love Grows",
				 // : "Opera - Maria and Draco",
				"12": "Swing de Chocobo",
				"13": "One-Winged Angel"
			}
		}
	}

    function updateAlbum( archive, id, property, value ) {
        // If empty, this signals a deletion of that property
    	if( value === "" ) {
    		delete archive[id][property];
    	}
    	else{
    		// Clear the old property
    		delete archive[id][property];
    		// Write the new property
    		archive[id][property] = value;
    	}
    }

    var newTrack = {"11" : "Opera - Maria and Draco"};
	updateAlbum( musicCollection, "1111", "tracks", newTrack );
    console.log( musicCollection["1111"]["tracks"]["11"] );

    // 2:10:00 - While loops
    while( true ) {
    	// Do this thing
    	break; // Or exit early with a break
    }

    console.log( "We escaped!" );

    // For loops
    for( var i = 0 ; i < 10 ; i++ ) {
    	console.log( "For loop: " + i );
    }

    // 2:13:00 - Looping on odd numbers
    // Can change the increment of i++ to i += <anything>
    // Can also subtract from i
    // Or multiply it. Or anything really

    // 2:17:00 - Iterating based on array.length

    function sumOfDigits( arg1 ) {
        var sum = 0;
        var argAsString = "" + arg1;
    	for( var i = 0 ; i < argAsString.length ; i++ ) {
    		sum += +argAsString[i]; // Use '+' to coerce to a number
    	}
    	return sum;
    }

    console.log( sumOfDigits( 12345 ) );

    function productOfDigits( arg1 ) {
        var argAsString = "" + arg1;
        var prod = Number(argAsString[0]);
    	for( var i = 1 ; i < argAsString.length ; i++ ) {
    		prod *= +argAsString[i];
    	}
    	return prod;
    }

    console.log( productOfDigits( 12345 ) );

    // Can use nested for loops to iterate over nested, jagged arrays

    // 2:22:00 - Do While loops
    // Do-while loops will run at least once, -then- check the condition
    do {
    	// The things to do
    } while( false ) // Check occurs after

    // 2:28:00 - Math.random

    console.log( Math.random() ); // From 0 (inclusive) to 1.00 (exclusive)

    // For random whole numbers:
    console.log( Math.floor( Math.random() * 100 ) ) // up to 99 (not including 100)

    // 2:32:32 - Number coercion from string
    console.log( parseInt( "123" ) );

    // 2:33:12 - Number coercion from binary
    console.log( parseInt( "100001010101", 2 ) ); // Base-2 radix (binary number)

    // Ternary operators
    // condition ? if-true : if false;
    // Can nest ternary operators

    // Let and const (versus var)
    // Let prevents us from declaring the variable twice

    // 2:38:59 - Strict mode - requires that variables be declared with var, let, or const
	"use strict";
    function strictFunction( ) {
    	myName = "JaneDoe";
    }
    strictFunction();

    // Generally, use 'let' all the time unless there's a specific reason not to

    // 2:41:00 - Const - Like 'let', but cannot be reassigned.
    const PI = 3.141569;

    // Reassignment is not the same as mutation, however
    // Arrays and objects can be mutated using bracket notation even if they are const

    // Object.freeze( <anObject> ); <- For if you don't want the object to change

    // 2:47:00 - Anonymous (lambda?) functions
    // ???

    // Anon functions with arguments

    // 2:50:00 - Map-filter-reduce

/*
    function <omit name> () {
    	// Function things
    };

    function () { // An anonymous function
	    // Function things
    };

	Can assign to a variable
	let myFunction = function () {};

	Can further remove the keyword 'function' in this case and replace with '=>'

*/
	let someFunctionFoo = ( arg1, arg2 ) => ( arg1 + arg2 );
	//  funcName     arguments         returns

	// Can read '=>' as 'passed to'

	// 2:54:00 - Rest operator - Packs all arguments to a function to a single array
	function sumDigits( ...args ) { // Arguments are packed to array
		var sum = args.reduce( (a, b) => (a + b) ); // Reduction applies the lambda function (a+b) to all elements of array
		console.log(...args); // Spread operator allows fast output of array contents ( 1 2 3 4 expected );
		return sum;
	}

	console.log( sumDigits( 1, 2, 3, 4 ) ); // Arbitrary number of arguments can be reduced

	// 2:56:33 - Spread operator for deep copy of arrays
	let arrayOriginal = [ 1, 2, 3 ];
	let arrayCopy = arrayOriginal; // Shallow copy, reference to the original array
	let arrayCopy2 = [...arrayOriginal]; // Deep copy, elements moved one by one

	// 2:57:00 - Destructuring assignment
	var voxel = {x: 1, y: 2, z: 3}; // Voxel object with an x,y,z coordinate

	// Destructuing maps existing variables to new ones
	let { x : foo , y : bar , z : baz } = voxel; // Let x map to food, y map to bar, z map to baz from 'voxel'
	console.log( foo );
	console.log( bar );
	console.log( baz );

	// Empty scope?
	{
		console.log( 12345 );
	}

	// Can do nested destructuring for objects that are nested
	let forecast = {
		today    : { min : 70, max : 80 },
		tomorrow : { min : 75, max : 85 }
	};
	let { tomorrow : { max : destructuredField } } = forecast;
	console.log( destructuredField );

	// 3:03:40 - Destructing assignment with the rest (remaining) operator
	let source = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
	let [ , , ...shortSource ] = source; // Omits the first two elements (empty elements), assigns the remainder
	console.log( [ ...shortSource ] );

	// 3:05:00 - Using destructuring assignment to pass object as function parameter
	function destructuringFunc( { field1, field2 } ) { // The argument passed will be destructured, looking for elements 'field1' and 'field2'
		console.log( field1 ); // Handled inside the function without the use of dot notation to dereference
		console.log( field2 ); // Dereference is performed by the {} in the function arguments
	}

	// Used in API calls to request or transfer just what information is needed from an object (better performance on the network)

	// 3:06:00 - Template literals
	let user = { name : "FooBarBaz", age : "23" }; // Use backticks for template literals.
	let greeting = `Hello, my name is ${user.name}!
I am ${user.age} years old!`;

	console.log( greeting );

</script>
